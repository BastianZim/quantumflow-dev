# Copyright 2019-, Gavin E. Crooks
#
# This source code is licensed under the Apache License, Version 2.0 found in
# the LICENSE.txt file in the root directory of this source tree.


import sympy as sym
from sympy.abc import t as sym_t  # Symbolic theta
from sympy.abc import theta as sym_theta  # Symbolic theta

from .base import BaseStdCtrlGate, BaseStdGate, OperatorStructure, Variable
from .bits import Qubit
from .gates import Unitary

__all__ = (
    "I",
    "Rx",
    "X",
    "XPow",
    "Y",
    "Z",
    "CX",
    "CXPow",
)


class I(BaseStdGate):  # noqa: E742
    r"""
    A 1-qubit identity gate.

    .. math::
        {autogenerated_latex}
    """
    cv_hermitian = True
    cv_operator_structure = OperatorStructure.identity
    cv_sym_operator = sym.Matrix([[1, 0], [0, 1]])

    def __init__(self, q0: Qubit) -> None:
        super().__init__([], [q0])

    @property
    def H(self) -> "I":
        return self  # Hermitian

    def __pow__(self, t: Variable) -> "I":
        return self


# end class I


class Rx(BaseStdGate):
    r"""A 1-qubit Pauli-X parametric rotation gate.

    .. math::
        {autogenerated_latex}

    Args:
        theta: Angle of rotation in Bloch sphere
    """
    cv_sym_operator = sym.Matrix(
        [
            [sym.cos(sym_theta / 2), -sym.I * sym.sin(sym_theta / 2)],
            [-sym.I * sym.sin(sym_theta / 2), sym.cos(sym_theta / 2)],
        ]
    )

    def __init__(self, theta: Variable, q0: Qubit) -> None:
        super().__init__([theta], [q0])
        self.theta = theta

    @property
    def H(self) -> "Rx":
        return self ** -1

    def __pow__(self, t: Variable) -> "Rx":
        return Rx(self.theta * t, *self.qubits)


# end class Rx


class X(BaseStdGate):
    r"""
    A 1-qubit Pauli-X gate.

    .. math::
        {autogenerated_latex}
    """
    cv_hermitian = True
    cv_operator_structure = OperatorStructure.permutation
    cv_sym_operator = sym.Matrix([[0, 1], [1, 0]])

    def __init__(self, q0: Qubit) -> None:
        super().__init__([], [q0])

    @property
    def H(self) -> "X":
        return self  # Hermitian

    def __pow__(self, t: Variable) -> "XPow":
        return XPow(t, *self.qubits)


# end class X


class XPow(BaseStdGate):
    r"""Powers of the 1-qubit Pauli-X gate.

    .. math::
        \text{XPow}(t) = X^t = e^{i \pi t/2} R_x(\pi t)

    ..math
        {autogenerated_latex}

    Args:
        t: Number of half turns (quarter cycles) in the Block sphere
    """
    cv_sym_operator = sym.exp(sym.I * sym.pi * sym_t / 2) * sym.Matrix(
        [
            [sym.cos(sym.pi * sym_t / 2), -sym.I * sym.sin(sym.pi * sym_t / 2)],
            [-sym.I * sym.sin(sym.pi * sym_t / 2), sym.cos(sym.pi * sym_t / 2)],
        ]
    )

    def __init__(self, t: Variable, q0: Qubit) -> None:
        super().__init__([t], [q0])
        self.t = t

    @property
    def H(self) -> "XPow":
        return self ** -1

    def __pow__(self, t: Variable) -> "XPow":
        return XPow(t * self.t, *self.qubits)


# end class XPow


class Y(BaseStdGate):
    r"""
    A 1-qubit Pauli-Y gate.

    .. math::
        {autogenerated_latex}

    mnemonic: "Minus eye high".
    """
    cv_hermitian = True
    cv_operator_structure = OperatorStructure.monomial
    cv_sym_operator = sym.Matrix([[0, -sym.I], [sym.I, 0]])

    def __init__(self, q0: Qubit) -> None:
        super().__init__([], [q0])

    @property
    def H(self) -> "Y":
        return self  # Hermitian

    def __pow__(self, t: Variable) -> "Unitary":  # FIXME
        return Unitary.from_gate(self) ** t


# end class Y


class Z(BaseStdGate):
    r"""
    A 1-qubit Pauli-Z gate.

    .. math::
        {autogenerated_latex}
    """
    cv_hermitian = True
    cv_operator_structure = OperatorStructure.diagonal
    cv_sym_operator = sym.Matrix([[1, 0], [0, -1]])

    def __init__(self, q0: Qubit) -> None:
        super().__init__(args=[], qubits=[q0])

    @property
    def H(self) -> "Z":
        return self  # Hermitian

    def __pow__(self, t: Variable) -> "Unitary":  # FIXME
        return Unitary.from_gate(self) ** t


# end class Z


class CX(BaseStdCtrlGate):
    r"""A controlled-X gate, also called controlled-not (cnot).
    Locally equivalent to ``Can(1/2, 0, 0)``.

    .. math::
           {autogenerated_latex}
    """
    cv_target = X

    def __init__(self, q0: Qubit, q1: Qubit) -> None:
        super().__init__(args=[], qubits=[q0, q1])

    @property
    def H(self) -> "CX":
        return self  # Hermitian

    def __pow__(self, t: Variable) -> "CXPow":
        return CXPow(t, *self.qubits)


# end class CX


class CXPow(BaseStdCtrlGate):
    r"""Powers of the controlled-X (CX, CNOT) gate.

    ..math
        {autogenerated_latex}

    Args:
        t: Power to which the CX gate is raised.
    """
    cv_target = XPow

    def __init__(self, t: Variable, q0: Qubit, q1: Qubit) -> None:
        super().__init__(args=[t], qubits=[q0, q1])
        self.t = t

    @property
    def H(self) -> "CXPow":
        return self ** -1

    def __pow__(self, t: Variable) -> "CXPow":
        return CXPow(t * self.t, *self.qubits)


# end class CXPow

# fin
